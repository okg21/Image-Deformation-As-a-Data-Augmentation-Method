#! /usr/bin/env python
# -*- coding: utf-8 -*-

import numpy as np
import tensorflow.experimental.numpy as tnp
import tensorflow as tf
import face_recognition

#implement the function above using tensorflow tensors
def tf_mls_affine_deformation(vx, vy, p, q, eps=1e-6, alpha=0.5):
    """
    Calculate the affine deformation field using MLS.
    :param vx: x-coordinates of the control points.
    :param vy: y-coordinates of the control points.
    :param p: x-coordinates of the target points.
    :param q: y-coordinates of the target points.
    :param eps: epsilon for the weight.
    :param alpha: alpha for the weight.
    :return: the affine deformation field.
    """
    """
    Affine deformation

    Parameters
    ----------
    vy, vx: ndarray
        coordinate grid, generated by tnp.meshgrid(gridX, gridY)
    p: ndarray
        an array with size [n, 2], original control points, in (y, x) formats
    q: ndarray
        an array with size [n, 2], final control points, in (y, x) formats
    alpha: float
        parameter used by weights
    eps: float
        epsilon
    
    Return
    ------
        A deformed image.
    """

    # Change (x, y) to (row, col)
    q = tnp.ascontiguousarray(q.astype(tnp.int16))
    p = tnp.ascontiguousarray(p.astype(tnp.int16))

    # Exchange p and q and hence we transform destination pixels to the corresponding source pixels.
    p, q = q, p

    grow = vx.shape[0]  # grid rows
    gcol = vx.shape[1]  # grid cols
    ctrls = p.shape[0]  # control points

    # Precompute
    reshaped_p = p.reshape(ctrls, 2, 1, 1)                                              # [ctrls, 2, 1, 1]
    reshaped_v = tnp.vstack((vx.reshape(1, grow, gcol), vy.reshape(1, grow, gcol)))      # [2, grow, gcol]

    w = 1.0 / (tnp.sum((reshaped_p - reshaped_v).astype(tnp.float32) ** 2, axis=1) + eps) ** alpha    # [ctrls, grow, gcol]
    w /= tnp.sum(w, axis=0, keepdims=True)                                               # [ctrls, grow, gcol]

    pstar = tnp.zeros((2, grow, gcol), tnp.float32)
    for i in range(ctrls):
        pstar += w[i] * reshaped_p[i]                                                   # [2, grow, gcol]

    phat = reshaped_p - pstar                                                           # [ctrls, 2, grow, gcol]
    phat = phat.reshape(ctrls, 2, 1, grow, gcol)                                        # [ctrls, 2, 1, grow, gcol]
    phat1 = phat.reshape(ctrls, 1, 2, grow, gcol)                                       # [ctrls, 1, 2, grow, gcol]
    reshaped_w = w.reshape(ctrls, 1, 1, grow, gcol)                                     # [ctrls, 1, 1, grow, gcol]
    pTwp = tnp.zeros((2, 2, grow, gcol), tnp.float32)
    for i in range(ctrls):
        pTwp += phat[i] * reshaped_w[i] * phat1[i]
    del phat1

    try:
        inv_pTwp = tnp.linalg.inv(pTwp.transpose(2, 3, 0, 1))                            # [grow, gcol, 2, 2]
        flag = False                
    except tnp.linalg.linalg.LinAlgError:                
        flag = True             
        det = tnp.linalg.det(pTwp.transpose(2, 3, 0, 1))                                 # [grow, gcol]
        det[det < 1e-8] = tnp.inf                
        reshaped_det = det.reshape(1, 1, grow, gcol)                                    # [1, 1, grow, gcol]
        adjoint = pTwp[[[1, 0], [1, 0]], [[1, 1], [0, 0]], :, :]                        # [2, 2, grow, gcol]
        adjoint[[0, 1], [1, 0], :, :] = -adjoint[[0, 1], [1, 0], :, :]                  # [2, 2, grow, gcol]
        inv_pTwp = (adjoint / reshaped_det).transpose(2, 3, 0, 1)                       # [grow, gcol, 2, 2]
    
    mul_left = reshaped_v - pstar                                                       # [2, grow, gcol]
    reshaped_mul_left = mul_left.reshape(1, 2, grow, gcol).transpose(2, 3, 0, 1)        # [grow, gcol, 1, 2]
    mul_right = tnp.multiply(reshaped_w, phat, out=phat)                                 # [ctrls, 2, 1, grow, gcol]
    reshaped_mul_right = mul_right.transpose(0, 3, 4, 1, 2)                             # [ctrls, grow, gcol, 2, 1]
    out_A = mul_right.reshape(2, ctrls, grow, gcol, 1, 1)[0]                            # [ctrls, grow, gcol, 1, 1]
    A = tnp.matmul(tnp.matmul(reshaped_mul_left, inv_pTwp), reshaped_mul_right, out=out_A)    # [ctrls, grow, gcol, 1, 1]
    A = A.reshape(ctrls, 1, grow, gcol)                                                 # [ctrls, 1, grow, gcol]
    del mul_right, reshaped_mul_right, phat

    # Calculate q
    reshaped_q = q.reshape((ctrls, 2, 1, 1))                                            # [ctrls, 2, 1, 1]
    qstar = tnp.zeros((2, grow, gcol), tnp.float32)
    for i in range(ctrls):
        qstar += w[i] * reshaped_q[i]                                                   # [2, grow, gcol]
    del w, reshaped_w

    # Get final image transfomer -- 3-D array
    transformers = tnp.zeros((2, grow, gcol), tnp.float32)
    for i in range(ctrls):
        transformers += A[i] * (reshaped_q[i] - qstar)
    transformers += qstar
    del A

    # Correct the points where pTwp is singular
    if flag:
        blidx = det == tnp.inf    # bool index
        transformers[0][blidx] = vx[blidx] + qstar[0][blidx] - pstar[0][blidx]
        transformers[1][blidx] = vy[blidx] + qstar[1][blidx] - pstar[1][blidx]

    # Removed the points outside the border
    transformers[transformers < 0] = 0
    transformers[0][transformers[0] > grow - 1] = 0
    transformers[1][transformers[1] > gcol - 1] = 0

    return transformers.astype(tnp.int16)

#custom data augmentation layer
class warpFace(tf.keras.layers.Layer):
    def __init__(self, p, intensity, mode, **kwargs):
        super(warpFace, self).__init__(**kwargs)
        self.p = p
        self.i = intensity
        self.mode = mode
    
    def call(self, images,training=None):
        if not training:
            return images
        
        #cast eagertensor to numpy array
        images = images.numpy()
        batch_size, height, width, channels = images.shape
        
        augs = []
        for rgb in images:
          #with 1-p probability return itself
          if tf.random.uniform([]) >= self.p:
            augs.append(rgb) 
            continue

          #get face landmarks 
          try:
            landmarks = face_recognition.face_landmarks(face_image=rgb)[0]
          except:
            augs.append(rgb)
            continue 
          #find control points
          if self.mode == "chin":
            if tf.random.uniform([]) > 0.5:
              org_points, new_points = self.deform_chin(self.i, "enlarge", landmarks)
            else:
              org_points, new_points = self.deform_chin(self.i, "thinner", landmarks)
          elif self.mode == "nose":
            if tf.random.uniform([]) > 0.5:
              org_points, new_points = self.deform_nose(self.i, "enlarge", landmarks)
            else:
              org_points, new_points = self.deform_nose(self.i, "thinner", landmarks)

            # Define deformation grid
            gridX = np.arange(width, dtype=np.int16)
            gridY = np.arange(height, dtype=np.int16)
            vy, vx = np.meshgrid(gridX, gridY)
            #warp image
            rigid1 = tf_mls_affine_deformation(vy, vx, org_points, new_points, alpha=1)
            aug1 = np.ones_like(rgb)
            aug1[vx, vy] = rgb[tuple(rigid1)]
            augs.append(aug1)
        augs = np.array(augs)
        return augs

    def get_config(self):
        config = super().get_config()
        config.update({
            "prob": self.p ,
            "intensity": self.i,
        })
        return config

    def deform_chin(self, alpha, mode, landmarks):
        if mode == "thinner":
            alpha *= -1
        x_dist = landmarks['chin'][16][0] - landmarks['chin'][0][0]
        org_points = []
        new_points = []
        for i, point in enumerate(landmarks['chin']):
            point = np.flip(point)
            org_points.append(point)
            if i<8:
                new_point = np.array([point[0], int(point[1] - x_dist * alpha)])
                new_points.append(new_point)
            elif i>8:
                new_point = np.array([point[0], int(point[1] + x_dist * alpha)])
                new_points.append(new_point)
            else:
                new_points.append(point)
        org_points = np.array(org_points)
        new_points = np.array(new_points)
        return org_points, new_points
    
    def deform_nose(self, alpha, mode, landmarks):
      if mode == "thinner":
          alpha *= -1
      org_points = []
      new_points = []

      #find a rectangle around nose and then widen this rectangle
      bottom_left_corner =  landmarks['nose_tip'][0]
      bottom_right_corner = landmarks['nose_tip'][4]

      nose_top = landmarks['nose_bridge'][0]

      nose_len = bottom_left_corner[1] - nose_top[1]
      nose_width = nose_top[0] - bottom_left_corner[0]
      for i in range(5):
          inter_point_left =(bottom_left_corner[0] +  (nose_width//5) * i, bottom_left_corner[1] - (nose_len//5) * i)
          inter_point_right =(bottom_right_corner[0] -  (nose_width//5) * i, bottom_right_corner[1] - (nose_len//5) * i)
          
          new_inter_point_left = (inter_point_left[0] - int(nose_width * alpha), inter_point_left[1])
          new_inter_point_right =  (inter_point_right[0] + int(nose_width * alpha), inter_point_right[1])

          #flip points
          inter_point_left = np.flip(inter_point_left)
          inter_point_right = np.flip(inter_point_right)
          new_inter_point_left = np.flip(new_inter_point_left)
          new_inter_point_right = np.flip(new_inter_point_right)

          org_points.append(inter_point_left)
          org_points.append(inter_point_right)
          new_points.append(new_inter_point_left)
          new_points.append(new_inter_point_right)

      org_points = np.array(org_points)
      new_points = np.array(new_points)
      
      return org_points, new_points